<!-- 20210907 화 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   고득점 kit

    *   정렬 - K번째 수 (레벨 1)

        *   완전탐색 - 모의고사 (레벨 1)

            **알고리즘**

            enum을 사용하는 코드가 여럿 보였는데 코드는 분석해두고 내 풀이방식은 그대로 제출했다

        *   완전탐색 - 소수찾기 (레벨 2)

            **알고리즘**

            숫자를 문자열로 입력할 때 조합만들기 = `list("숫자")`로 숫자를 문자열로 분해시킨 다음 `permu = list(map(int, map(''.join, itertools.permutations(numlist, i))))` (i는 문자열의 갯수만큼 반복문으로 1자리~n자리수의 조합을 구하기 위해 사용)

            에라토스테네스의 체 만들 때 d = [0] + [0] + [1] * (maxnum -1) 방식을 쓰니까 따로 0,1번째 숫자 처리 안해서 편하다.

        *   완전탐색 - 카펫 (레벨 2)

            가로x세로 (가로는 세로보다 같거나 크다)의 리스트를 [x, y] 형태로 출력
            내부 넓이 => brown + yellow = x * y (x >= y)
            yellow 넓이 => (정답 h-2) * (정답 w-2)

            **알고리즘**

            넓이를 3까지 줄이면서 넓이 자체와 나눠준다. -> 큰 수부터 구해주므로 처음 결과 나오면 바로 리턴

            특정 문제에서 루트를 씌운 값을 사용했는데 그 이유는 약수를 구할 때 range(1, sqrt(n)+1) 까지만 시도하면 나머지는 역으로 계산해서 같은 값이 나오기 때문

            또는 **근의공식**을 활용한 케이스가 있다. (구현 실패했음 ㅠ)

        *   탐욕법 - 조이스틱 (레벨 2)

            조이스틱은 위(다음 알파벳), 아래(이전 알파벳, A에서 쓰면 Z로 감), 왼쪽(커서 왼쪽이동, 0번에서하면 마지막 위치로), 오른쪽(커서 오른쪽이동)이 있다.

            처음에는 A로 이뤄진 문자열이 주어지고 첫 인덱스 위치에 위치한다. (완료해도 그 자리에 커서 유지)

            A=0 Z=26으로 잡고 하면 될거같은데..? A를 만난다면 왼쪽이나 오른쪽 중 어디로 갈지 결정도 해야함

            **알고리즘**

            남은 A의 갯수 확인하는 방법 `.count('A')`으로 남은 문자가 A로만 이뤄져있는지 확인 가능하다.

            11번 문제에서 에러가 계속 발생해서 이유를 찾아보니.. ABAAAAAABB 같은 케이스에서는 우측으로 한번 이동 후 다시 왼쪽으로 돌아서 끝까지 가는 방법이 훨씬 효율적이다!
            즉 한쪽으로만 이동하는 방법만이 정답이 아닌 경우가 존재한다.. 후.. 이 경우도 하나의 알고리즘으로 잡아야겠다.

*   ### 운영체제

    프로세서와 스케쥴러 - 프로세스 구조와 스택 오버플로우

    프로세서와 스케쥴러 - 컨텍스트 스위칭 원리
    
    프로세서와 스케쥴러 - 컨텍스트 스위칭 개념 정리
    
    프로세서와 스케쥴러 - 프로세스간 커뮤니케이션