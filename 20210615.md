<!-- day 9 -->
### 1. 오늘 한 일
- 알고리즘 공부
- 알고리즘 문제풀이

---
### 2. 오늘의 공부 정리 🗒️
#### 1. 스택
데이터를 넣기 때문에 링크드리스트로 구현하는게 좋다.
#### 2. 큐
#### 3. 해쉬
해쉬함수로 색인을 배열의 인덱스로 계산한다.
검색과 저장이 빠르게 진행된다.
딕셔너리는 내부적으로 배열을 사용한다.
> 해쉬함수 `hash('값')`
> 임의의 길이를 갖는 메시지를 받아 고정된 길이의 해쉬값을 출력하는 함수.
> 이렇게 나온 결과값을 정해진 길이(array의 길이)로 나누면 나머지 값이 인덱스에 해당한다.
> 해쉬함수를 계산하는데 걸리는 시간은 O(1)

해쉬함수에서 같은 인덱스가 여러개 나올 때 일어나는 충돌을 해결하는 방법
1. 체이닝: 링크드리스트 방식 (키를 같이 저장해야 찾을 수 있다.)
2. 개방주소법: 우선은 저장하고 겹칠 때 남는 공간에 넣는 방법

✏️ 딕셔너리 내부의 정렬을 할때 좋은 방법으로는 items()라는 메소드가 있다. 이걸 이용하면 (key, value) 형태로 리스트가 출력되는데 value 값을 기준으로 정렬하고 싶다면
`sorted(a.items(), key=lambda item:item[1], reverse=True)` => 람다식으로 item의 1번 인덱스값을 기준으로 정렬을 한다는 뜻


---

#### 설탕 배달 해설: 5a + 3b = n 을 만족시키는 a+b의 갯수를 구하는데 내가 계속 5를 먼저 빼던 버릇때문에 답이 안나왔다.
그리디에서 더 낮은 숫자인 3만큼의 봉지를 하나씩 추가하면서 남은 설탕을 5로 나누기를 시도하는 방식이 만족시키는 방법이였다.
while 문 작은 3 사이즈 아래일 경우 탈출
