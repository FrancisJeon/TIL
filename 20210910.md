<!-- 20210910 금 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   고득점 kit

        *   해시 - 베스트앨범 (레벨 3)

            1- 속한 노래가 많이 재생된 장르 먼저 수록(합), 2- 장르내에서 많이 재생된 노래 먼저 수록, 3- 장르내에서 횟수가 같은노래중 고유번호(인덱스)) 낮은 노래 먼저 수록
            genre[i] 고유번호 i인 노래 장르, plays[i] 고유번호 i인 노래 재생된 횟수
            장르 속한곡 한개면 하나의 곡만선택되고 재생된 횟수는 모두 다르다.

            **알고리즘**

            `defaultdict` 클래스의 생성자로 기본값을 생성해주는 함수를 넘기면, 모든 키에 대해서 값이 없는 경우 자동으로 생성자의 인자로 넘어온 함수를 호출하여 그 결과값으로 설정해준다. `defaultdict(int) 또는 defaultdict(lambda: 0)`

            딕셔너리를 팝할 수 있다? `defaultdict`는 pop(0)을 하면 0번째 인덱스를 빼는것 같다. 하지만 일반 딕셔너리에 pop(0)을 하면 오류 발생 -> 일반 딕셔너리는 pop 내부에 키값만 받는 것 같다.

            defaultdict가 아닌 일반 딕셔너리로도 해결이 가능한데 value를 검색할 때 + 연산을 잘 활용하는 방법을 써준다.

        *   힙 - 이중우선순위큐 (레벨 3)

            "I 숫자" - 큐에 주어진 숫자 삽입, "D 1" 최대값 삭제, "D -1" 최솟값 삭제 
            큐가 비어있으면 삭제하라는 연산 무시한다. 
            최댓값 최솟값 둘 이상일 때 한개만 삭제
            모든 명령이 끝난 뒤 비어있으면 [0, 0] 반환, 비어있지 않다면 [최댓값, 최솟값]

            **알고리즘**

            데크를 사용해서 풀긴했는데 이 문제는 heapq를 사용해서 풀어야 할것 같다.

            maxheap 구현하는 방법은 숫자를 -로 넣고 뺄 때 -를 붙여서 나오게 한다. `heapq.heappush(heap iter, n) heapq.heappop(heap iter, n)`

            heapify도 써보고 싶다. 나중에

        *   이분탐색 - 입국심사 (레벨 3)

            n명이 대기중인데 심사관마다 걸리는 시간이 다르다. times가 심사관마다 심사하는 시간이고 모든 사람이 심사를 마친다면 그 시간을 출력한다.
            예외 - 만약 심사관이 심사를 볼 수 있는 상황인데 기다린 후 다른 심사관한테 받는 속도가 더 빠르다면 그 심사관한테 심사를 받을 수 있다. (읭?)

            심사관의 숫자보다 적은사람이 나오는 첫 시간을 계산하고.. 나머지 인원에 대해서는 남은시간에 맞춰서 심사관들한테 다 넣어주면 ? X 오답

            n의 시간을 찍어서 이 시간에 다 받아짐? min max 돌려가면서 난리를 치다가 최소값 딱 떨어질때 찾는거같음

        *   다이나믹 프로그래밍 - N으로 표현 (레벨 3) - **미해결**

            n이 주어지면 n을 활용해서 number를 만들기 최솟값이 8보다 큰 경우엔 -1을 출력하고 사칙연산은 1개 쓸 때마다 return 값이 1 증가한다.

            nn을 사용하면 55 같은 숫자도 표현 가능하다.

            return값 자리수에 해당하는 NNNNN + NNNN .... 을 만들고 N으로 나누는 방법도 있다
            
            

