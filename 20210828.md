<!-- 20210828 토 -->
<!--  




-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   프로그래머스

        -   2019 카카오 겨울 개발자 인턴 -> 호텔 방 배정

            [0] * k 의 방 목록에 배정할 때 원래 목표한 방이 비어있지 않다면 (0이 아니면) 다음 인덱스로 이동시키다가 0을 만날 때 그 방의 번호를 정답지에 append한다. 

            -> **효율성**에서 틀린 답으로 나왔다.

            딕셔너리 get(k, n) 함수 = 딕셔너리에서 k라는 키의 value 반환, 없을시 n값을 반환

            만약 dictionary에 해당 방번호 사용자를 키, 그 번호보다 하나 높은 수를 값으로 한 키:값 쌍 딕셔너리를 만들어서 보관을 한다면 새로운 사용자가 나타날 때 마다 '키'가 없는곳까지 가는 함수를 생성할 수 있다.

            visit 이라는 방문 기록 리스트도 활용하는게 효율을 높이는데 도움된다.

        *   2019 카카오 겨울 개발자 인턴 -> 징검다리

            모든 징검다리 갯수를 1씩 감소시키다가 징검다리가 0 이하인 곳이 k개일 때 종료하는 조건으로 작성했는데 N^2 시간복잡도 (브루트 포스) -> **효율성 오답**

            정답코드를 찾아보니 최대값의 캐릭터 갯수가 2억이므로 **이분탐색**으로 해결하는 방법을 사용한다. 이렇게 하면 logN으로 획기적으로 줄일 수 있다.

            stones의 최대값을 max로 잡고 1을 min으로 잡는다. (k = 1 일경우 stones의 최솟값이 답이기 때문)

            그리고 min < max를 비교한 다음 중간지점으로 mid를 만들어서 mid값보다 작은 stone들이 k번 연속되는 경우를 기준으로 이분탐색을 진행한다.

            