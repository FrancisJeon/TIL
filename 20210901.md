<!-- 20210901 수 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   코딩테스트 연습

        *   스택/큐 - 기능개발 (210812.md)

            알고리즘 - zip 함수 사용법이나 math라이브러리 ceil 활용하는 방법

            반복문을 돌면서 내부의 값들을 특정 범위로 나눌 때는 인덱스를 기록하는 변수를 하나 가져가면 좋다.

        *   힙 - 더 맵게 (210819.md)

            heapq 라이브러리를 사용했다.

            heapify(iter객체)를 사용하면 최소 힙으로 변환 된다. 

            heappop(iter객체)을 사용하면 가장 작은 원소가 반환된다.

            heappush(넣을 heapq 변수, 넣을 값)로 새로 만들어진 스코빌 음식을 다시 넣어줄 수 있다.

            return answer에 조건문을 넣어서 코드를 단축하는 방법도 있다.
            
        *   2018 카카오 1차 - 프렌즈 4 블록 (정답률 - 48%)

            **알고리즘**

            ```
            높이 = m, 넓이 = n으로 [m]*[n] 크기의 2차원배열이 만들어진다
            반복문을 돌면서 우측, 아래로 향하는 2*2 범위를 측정해서 같은값일 경우 인덱스를 저장해두었다가 Empty로 변경
            처음에는 반복문으로 2차원 배열을 생성하지 않고 주어진 입력값을 기준으로 한번 제거하고 끝내려고 했는데 제거 후 새로 만들어진 블록도 다시 체크해야해서 안된다.
            1) 블록을 제거할 수 있는 상태인지 체크하는 함수를 만들어서 False가 나올때까지 반복문 돌려주기로 했고 True일땐 
            2) 4개 블록을 E로 바꾸는 함수 생성
            3) E로 바꾼 다음 떨어져서 새로운 블록 생성하는 함수도 만들어야 할듯
            ```

            시뮬레이션 문제, set 이용, 2차원 배열 처리

            **코드**

            2차원 리스트 생성할 때 입력 받는 값 for문 돌리면 정상적인 입력이 안된다.

            -> list comprehension으로 생성해주면 된다. (배열 레퍼런스랑 관련된 듯하다)

            ```
            2차원 리스트의 한 좌표에서 인접 리스트 요소(상하좌우 값)를 탐색하고 싶을 때 2중 반복문 내에서 사용하는 방법은 다음과 같다.
            dx=[0,0,-1,1] #상하좌우
            dy=[-1,1,0,0]
            newX = i + dx
            newY = j + dy
            ```

            *   append에는 여러 인자를 넣어줄 순 없으므로 += 연산자로 리스트를 추가해줘도 된다.

            *   reversed(range(x)) 이것도 유용함 (역순 출력할 때)

            *   `list(map(list, zip(*리스트변수)))` *의 사용법중 하나로 리스트의 데이터를 unpacking하여 **함수에** 전달한다.

                행렬이 Transpose 된 값이 나온다.

                https://programmers.co.kr/learn/courses/4008/lessons/13318

                ```
                list_var = ["TTTANT", "RRFACC", "RRRFCC", "TRRRAA", "TTMMMF", "TMMTTJ"]
                list(map(list, zip(*list_var))) 
                => [['T', 'R', 'R', 'T', 'T', 'T'], ['T', 'R', 'R', 'R', 'T', 'M'], ['T', 'F', 'R', 'R', 'M', 'M'], ['A', 'A', 'F', 'R', 'M', 'T'], ['N', 'C', 'C', 'A', 'M', 'T'], ['T', 'C', 'C', 'A', 'F', 'J']]
                ```

                unpacking은 다른 방식으로도 사용이 가능한데... divmod(a, b)의 값이 튜플형태로 반환이 된다면 앞에 *을 붙여주면 원소를 하나하나 출력해서 int형으로 반환한다.

    *   파이썬 알고리즘 책 (~76p.)

        챕터 2


​    
