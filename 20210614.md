<!-- day 9 -->
### 1. 오늘 한 일
- 알고리즘 공부
- 알고리즘 문제풀이

---
### 2. 오늘의 공부 정리 🗒️
1. 스택
데이터를 넣기 때문에 링크드리스트로 구현하는게 좋다.

2. 큐
3. 해쉬
해쉬함수를 이용해서 색인을 배열의 인덱스로 계산한다.
검색과 저장이 빠르게 진행된다.
딕셔너리는 내부적으로 배열을 사용한다.

 **해쉬함수** 
 `hash('값')`
 임의의 길이를 갖는 메시지를 받아 고정된 길이의 해쉬값을 출력하는 함수.
 해쉬함수의 결과값을 정해진 길이(array의 길이)로 나누면 나머지 값이 인덱스에 해당한다.
 해쉬함수를 계산하는데 걸리는 시간은 *O(1)*

 해쉬함수에서 같은 인덱스가 여러개 나올 때 일어나는 충돌을 해결하는 방법
 	1. 체이닝: 링크드리스트 방식 (키를 같이 저장해야 찾을 수 있다.)
  	2. 개방주소법: 우선은 저장하고 겹칠 때 남는 공간에 넣는 방법

 ✏️ **딕셔너리 내부의 정렬**을 할때 좋은 방법으로는 `items()`라는 메소드가 있다. 
 이걸 이용하면 (key, value) 형태로 리스트가 출력되는데 value 값을 기준으로 정렬하고 싶다면
 `sorted(a.items(), key=lambda item:item[1], reverse=True)` 로 정렬시키기
 item의 1번 인덱스값을 기준으로 정렬을 한다는 뜻

---
#### 설탕 배달 문제
5a + 3b = n 을 만족시키는 a+b의 갯수를 구하는데 계속 5를 먼저 빼던 습관때문에 답이 안나왔다.
그리디 알고리즘에서 더 작은 숫자인 3kg 봉지를 한개씩 추가하면서 남은 설탕을 5kg으로 나누는 방식이 최소갯수를 구하는 방법이였다.
