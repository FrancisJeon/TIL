<!-- 20211008 금 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 알고리즘

    *   팁

        

    *   문제풀이

        *   백준 1920 수 찾기 - 이분탐색

            N과 A[1:N+1]개의 정수가 순차적으로 주어지고 다음 줄에는 M과 M개의 수들이 주어지는데 이 수들이 array A에 들어가는지 여부를 한줄씩 출력한다. 존재하면 1 없으면 B

            이분탐색을 사용해보겠다. (이분 탐색을 위해선 sorting이 필수)

            이분탐색 조건 l <= r 과 array[mid] > i 등에서 l, r 값 변화를 머리속에 익혀두자

            1.  정석 이분탐색 알고리즘은 시간이 조금 걸리는 편
            2.  라이브러리를 사용해보겠다. -> bisect_left가 속도는 절반으로 줄여주는 대신 약간 까다롭다. bisect_left에서 초과하는 상황에 index 에러가 날 수 있다.
            3.  for i in array와 set를 섞어서 쓰면 가장 빠른 속도로 정답을 출력할 수 있다.

        *   백준 10815 숫자카드 - 정렬, 이분탐색

            1920번과 출력에 변형을 주긴 해도 거의 유사해서 같은 방법으로 풀어봤다.

            1.  for i in arr - 708ms
            2.  bisect_left - 1416ms

        *   백준 2749 피보나치 수 3 - 분할정복

            최대 입력값이 터무니 없이 크게 나와서 미리 사이즈를 잡아두는 memoization을 활용할 경우 에러가 발생한다. -> 메모이제이션은 O(n) 시간이라고 한다.

            defaultdict로 시도해보기 -> recursion 에러 발생

            *   **행렬곱셈**을 이용한 피보나치

                https://rhdtka21.tistory.com/122, 
                https://shoark7.github.io/programming/algorithm/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-5%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95.html

                행렬의 지수식으로 표현하면 지수를 계산하는 알고리즘을 이용할 수 있다고 한다.

            *   피사노 주기 https://www.acmicpc.net/blog/view/28

                피보나치 수를 K로 나눈 나머지는 항상 주기를 가지게 되는데 이를 피사노 주기라고 한다.

                주기의 길이가 P라면 N번째 피보나치 수를 M으로 나눈 나머지는 N%P번째 피보나치수를 M으로 나눈 나머지와 같다.

                M = 10^k 일 때, k > 2라면 주기는 항상 15 * 10^(k-1) 입니다.

            *   정답 알고리즘

                ```
                # 메모이제이션을 활용했지만 150만번의 반복을 활용해서 풀었다?
                import sys
                input = sys.stdin.readline
                memo = [0,1]
                N = int(input())
                for i in range(2, 1500000):
                    memo.append((memo[i-2] + memo[i-1]) % 1000000)
                print(memo[N % 1500000])
                # 딕셔너리에 홀수와 짝수의 케이스를 가지고 풀었다.
                dic = {
                    0:0,
                    1:1,
                    2:1,
                }
                # 피사노 주기 활용?은 아닌거같은데 이건
                def f(n):
                    if n in dic:
                        return dic[n]
                    if n%2==1:
                        dic[n] = (f(n//2)**2 + f(n//2+1)**2)%1000000
                    else:
                        dic[n] = (2*f(n//2-1)+f(n//2))*f(n//2)%1000000
                    return dic[n]
                
                n = int(input())
                print(f(n))
                ```

        *   백준 10867 중복 빼고 정렬하기

        *   **백준 1406 에디터 - 미완**

            코드가 어렵진 않은데 신경쓸게 많아서 내일 제출하기로

