<!-- 20210904 토 -->
<!--  

파이썬을 파이썬답게

-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   코딩테스트 연습
        *   **공부한 알고리즘, 코드 정리**

            *   코딩테스트

            "08:00"을 split(":") 해주면 08, 00 으로 나뉜다. 또는 스플릿을 이용해도 된다.

            list comprehension을 이용해서 리스트를 만들 때 바로 .sort()를 하면 정상적으로 정렬이 안되니까 다음 줄에 따로 sort()를 해줘야 한다.

            *   라이브러리

            bisect 라이브러리 - 이진 탐색을 활용하므로 정렬 상태여야 된다.

            bisect_left(iterator, 목표값), bisect_right(iterator, 목표값)

            bisect_left는 목표값을 넣을 때 목표값을 삽입할 수 있는 가장 왼쪽 인덱스 값 반환

            bisect_right는 목표값을 넣을 때 목표값을 삽입할수 있는 가장 우측 인덱스 값 반환한다.

            이를 이용해서 같은 값을 목표로 넣을 경우 반복자 내 특정 값의 갯수를 구하는데 사용할 수 있다.   

        *   2018 카카오 1차 - 셔틀버스

            09:00부터 n회 t분 간격으로 최대 m명이 탄다.

            도착한 순간에 대기열에 선 크루까지 포함해서 바로 출발

            크루가 대기열 도착하는 시간표 HH:MM 형식으로 이루어진 타임테이블이 주어진다.

            출력 = 콘이 무사히 셔틀 타고 사무실 갈 수 있는 제일 늦은 도착시간을 출력한다.
        
            **알고리즘**
        
            "08:00"을 split(":") 해주면 08, 00 으로 나뉜다. 또는 스플릿을 이용해도 된다.
        
            list comprehension을 이용해서 리스트를 만들 때 바로 .sort()를 하면 정상적으로 정렬이 안되니까 다음 줄에 따로 sort()를 해줘야 한다.
        
            셔틀버스 시작시간 ~ 끝시간을 하나의 리스트로 만들어서 반복문을 그 안에서 돌리면서 대기중인 크루원들을 전부 반복을 시켜주기
        
            조건을 잘 만들어야한다. counter과 m(최대 탑승인원)을 활용하면서 크루가 남아있는지 아닌지도 확인해야 한다.
        
    *   항해 99
    
        DFS & BFS
    
        *   재귀로 DFS 구현하기
    
            만약 Dictionary를 반복문을 돌린다면 나오는것은 key값들이 나온다.
    
            그리고 그 dictionary[key]를 반복문을 돌리면 value가 iterable 일 때 그 리스트의 반복문을 돈다.



​        
