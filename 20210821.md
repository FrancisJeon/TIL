<!-- 20210821 토 -->
<!--  




-->

## 1. 오늘 한 일 📅

*   패스트 캠퍼스

## 2. 오늘의 공부 정리 🗒️

-   ### C언어

    *   패스트캠퍼스

        10강 문자

        getchar()을 이용해서 하나의 문자를 입력받을 수 있다.

        문자열을 처리할 때 버퍼의 개념이 많이 사용된다. 버퍼란 임시적으로 특정 데이터 저장 목적으로 사용된다.

        남아있는 입력 버퍼를 지우기 위해선 (개행문자 또는 파일의 끝)

        int temp;

        while ((temp = getchar()) != EOF && temp != '\n') { }

        11강 문자열

        문자열은 메모리 구조상 마지막에 NULL값을 포함한다.

        문자열 포인터 사용하면 포인터에 문자열의 주소를 넣는다.

        gets() 함수는 공백까지 포함하여 한 줄을 입력받는다. (실무에서는 보안상 다른 함수를 쓰지만 이해를 위해서 gets 사용)

        gets_s(a, sizeof(a)) : gets_s 함수는 얼마나 받을지 버퍼 크기를 입력하게 해서 정해진 입력값만 받게 한다.

        문자열 처리를 위해 <string.h> 라이브러리를 사용한다.

        12 변수

        전역 변수 - 메인함수 밖에 선언된 변수로 데이터 영역에 적재되고 시작과 동시에 메모리에 할당된다.

        지역 변수 - 특정한 블록에서만 접근할 수 있는 변수로 함수 실행될 때마다 메모리에 할당된다.

        정적 변수 - 특정한 블록에서만 접근(지역변수 느낌)할 수 있는 변수로 프로그램이 종료되면 메모리에서 해제된다. 실행될 때 메모리에 할당(전역 변수같은 느낌)

        ​	static 을 붙인 변수 (여러번 함수를 실행하면 계속 값이 증가된다.)

        레지스터 변수 - 메인 메모리 대신 cpu의 레지스터를 사용하는 변수 -> 레지스터 속도는 훨씬 빠르지만 매우 한정된 부분으로 실제로 여기서 처리될 지 미지수

        ​	register을 붙인 변수

        매개변수 처리될 때 -> 값에 의한 전달 방식과 참조에 의한 전달 방식이 존재한다.

        값에 의한 전달을 할 경우 처음 사용한 변수를 매개변수로 쓴다면 변수 값은 그대로 유지된다.

        참조에 의한 전달 방식은 값이 아닌 변수의 주소를 전달해주면 된다. 파라미터에는 *a 포인터로 넣어주고 그 값을 변경시켜주면 된다. 매개변수에는 &a

        13 다차원 배열과 포인터 배열

        다차원 배열의 필요성 = 행렬 데이터를 표현, 그래프 알고리즘 처리, 실생활 데이터 처리할 때 사용

        1차원 배열이 중첩된 의미로 \[행]\[열] 대괄호를 두번 중첩한다.

        2중 for문과 함께 많이 사용된다.

        int a\[3]\[3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };

        다차원 배열 - 2차원 배열 이상의 다차원도 가능하지만 컴퓨터는 2차원 배열 형태로 보여준다.

        포인터는 변수지만 배열은 **상수**이다

        14 동적 메모리 할당

        동적 = 프로그램 실행 도중에

        c언어에서는 malloc() 함수를 이용해 원하는 만큼의 메모리 공간을 확보한다. <stdlib.h> 라이브러리 사용

        성공하면 주소를 반환하고 실패하면 null을 반환

        동적 할당 변수는 힙 영역에 저장된다.

        동적 할당 변수는 free() 함수로 메모리 해제해줘야 한다.

        동적으로 문자열 처리하기 - 일괄적 **범위의 메모리를 모두 특정한 값으로 설정**하기 위해서는 memset()을 사용합니다. <string.h> 라이브러리에 있다.

        `memset(포인터, 값, 크기)`

        16 구조체

        구조체로 자신의 자료형을 만들 수 있다.

        구조체는 여러개의 변수를 묶어 하나의 객체를 표현하고자 할 때 사용한다. (캐릭터 몬스터 학생 등 모두 표현 가능)

        struct 구조체명 { 자료형 변수명 .... };

        typedef를 붙여서 구조체를 만들면 더 짧게 구조체 정의가 가능하다. 기존에는 struct를 붙여야 생성이 가능했는데 이렇게 해주면 구조체 앞에 struct를 안붙여도 생성이 가능. 또한 익명 구조체로 typedef struct 뒤에 구조체 명 비워도 작동한다.

        구조체가 포인터 변수로 사용되는 경우 내부 변수에 접근할 때 화살표를 사용한다. s->studentId

        17 파일 입출력

        프로그램이 꺼진 이후에도 데이터를 저장하기 위해서 필요하다.

        FILE 형식의 포인터 변수로 파일 입출력 변수를 선언한 다음 fopen, fclose를 사용한다.

        r = read, w = write, a = 데이터를 가장 마지막에 이어서 write

        fprintf(파일포인터, 서식, 형식지정자)와 fscanf(파일포인터, 서식, 형식지정자)로 입출력을 해준다.

        fopen -> file read/write -> fclose 순서를 지켜줘야 한다.

        18 전처리기

        전처리기 = 다른 프로그램 영역과 독립적으로 처리된다. 소스코드 파일 단위로 효력이 존재한다.

        #include는 가장 많이 사용되는 전처리기 문법이다.

        #include로 불러오는 파일에는 제약이 없다.

        <파일이름> 꺽쇠괄호는 시스템 디렉토리에서 파일을 검색한다.

        "파일이름" 쌍따옴표는 현재 폴더에서 먼저 검색하고 그 다음 없을 때 시스템 디렉토리에서 검색한다.

        .h 로 헤더파일 생성해주면 나만의 헤더파일 만들 수 있다. 헤더 파일 내부에는 함수를 만들어 주면 main 함수에서 불러서 사용해줄 수 있다. 

        #include는 전부를 가져오기 때문에 의도치 않게 같은 헤더를 여러번 참조하지 않게 주의하기

        매크로 전처리기 -> 상수나 함수를 매크로 형태로 저장하기 위해 사용한다 #define을 사용하면 정의할 수 있다.

        #define 문법에는 인자를 넣어줄 수 있다. #define POW(x) (x * x) == 제곱을 전처리 해둠

        #define ll long long, #define ld long double로 자주 적어줘야 하는 소스코드의 길이를 줄일 수 있다.

        조건부 컴파일

        #ifndef ~ #endif 문법은 헤더파일의 중복을 막기위해 사용해준다. 헤더 내부에 #ifndef \_TEMP_H_ #define \_TEMP_H_ #endif 세줄을 잘 넣어주면 된다.

        파일 분할 컴파일

        직접 라이브러리를 만들 때에는 c언어 파일, 헤더파일을 모두 작성해야 한다.

        헤더파일 내부에는 int add(int a, int b); 함수의 형태만 적어두고 헤더와 동일명의 c파일에 정의해주면 된다. c파일에는 h파일을 담고 있다는 #include를 적어주면 된다.

    