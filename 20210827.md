<!-- 20210827 금 -->
<!--  




-->

## 1. 오늘 한 일 📅

*   

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   파이썬 알고리즘 책

        챕터 1 - Reinforcement 문제 풀이

    *   프로그래머스

        *   **완주하지 못한 선수** (210811.md) - 스터디

            해쉬문제의 취지에 맞게하려면 `dict()` 딕셔너리 사용해서 풀어주기
            기존에 딕셔너리에 없을때 dict[key] = 1, 있을경우 += 1
            `del dict[key]`로 딕셔너리에 있는 값을 삭제할 수 있다. (값이 0일때 삭제하는 방법이 좋을듯)
            딕셔너리의 key값 가져오려면 `key, value in dict.items()`

            Counter 사용하면 set처럼 비교할 수 있다.

        *   2019 카카오 겨울 개발자 인턴 -> 인형뽑기 게임

            2차원 배열의 인덱스를 2중 for문으로 접근해서 stack을 활용했다.

            난이도는 어렵지 않았는데 스택에 더 가까운 방법으로 풀이하려고 노력해야겠다.

        *   2019 카카오 겨울 개발자 인턴 -> 튜플

            `list(eval(s[1:-1]))` -> 정상적인 리스트 형태로 변경된다.

            `sorted(iter, key = len)` -> 원소의 길이순으로 정렬

            정리 = 내가 몰랐던 메소드들로 인해서 런타임 에러가 발생했는데 문제를 더 풀어보면 알 수 있는 코드들이 많을 것 같다.

            문자열을 가공해서 리스트 또는 집합자료로 바꿔주는 방법들이 다양하게 존재하는데 eval 활용 또는 `split('},{')` 으로 iter 객체로 바꿔주자

            set()에서 차집합을 사용해서 나온 결과는 바로 리스트에 append 할 수 없고 해주려면 list로 바꿔서 [0] 인덱싱을 해주면 된다.

            Counter을 사용한 방법도 있는데 이건 라이브러리에 익숙해질 필요가 있다.

        *   2019 카카오 겨울 개발자 인턴 -> 불량 사용자

            정규식으로 경우의 수 찾기..? -> X

            ```
            fr*d*, abc***의 경우
            fr*d*가 될 수 있는 갯수와
            abc***이 될 수 있는 갯수를 찾은 다음
            두개로 만들 수 있는 조합 (중복X)를 찾아서 갯수 만들기 (콤비네이션)
            ```

            **정답 코드**

            *   combination은 중복이 제거되고 permutation은 중복이 담기지만 이 문제에서는 순서 때문에 permutations를 사용하고 중복은 나중에 제거해준다. -> 정답 조합 다 비교하고 list() sorted() 후 정답에 넣을 때 중복항목은 안넣는 방법

            ```
            # permutation은 필수로 쓰는것 같다. 가능한 밴 조합들을 다 만든 다음 ban_id와 user_id를 글자별로 비교하는 함수 활용
            import itertools
            possible_combinations = `list(itertools.permutations(user_id, len(banned_id)))`
            ```
            

            


