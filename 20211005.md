<!-- 20211005 화 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 알고리즘

    *   팁

        *   다익스트라 알고리즘 

            큐를 활용한다. 비용과 현재 노드 정보를 담아준 뒤 비용은 계속 다음 위치로 넘어가면서 큐에 추가시키고 graph[now]를 반복문 돌리면서 연결된 모든 노드들에 대해서 연산을 진행

        *   defualtdict 라이브러리

            list_dict = defaultdict(자료형) - 자료형태가 디폴트 값인 딕셔너리가 만들어진다.

            이렇게 만든 딕셔너리는 존재하지 않는 키의 값이 0 또는 빈 반복자로 생성된다.

            리스트의 경우에는 value를 여러개 붙여야 한다면 append를 활용한다.

    *   문제풀이

        *   백준 1916 최소비용 구하기 - 다익스트라, 벨만포드 뼈대문제

            1 - 2~5까지 가는 비용과 다른 구간을 통과해서 가는 비용을 비교하면서 최소 비용으로 만들어야 한다. (다익스트라 알고리즘)

            DFS/BFS를 더 잘 다뤄야 할 듯 하지만 일단 문제를 푼 뒤 DFS/BFS에 집중하기로

            *   딕셔너리중 **defaultdict**를 그래프로 활용 -> 사용법 정리하기

            *   distances 는 [INF]로 N+1개를 해준다. (숫자를 그대로 index에 활용하기 위해)
            *   s, e, c를 리스트 컴프리헨션으로 제작하지 않고 graph[s].append((e, c)) 형태로 제작해주기
            *   다익스트라는 heap을 이용하면 편하다. (가장 가까운 거리를 기준으로 정렬되기 때문)

        *   백준 6996 애너그램

            *   counter 같은 형태로 딕셔너리를 만들어서 비교하면 될 것 같음

            *   다른 방법으로는 ord()의 sum을 활용한 방법이다. 글자의 길이가 같게 주어지고 완전히 다른 단어가 주어지지 않을거라는 가정 때문인데, 만약 AZ와 OO 처럼 sum이 같은 경우가 존재하는 이상한 단어가 주어지면 에러가 발생할 것이다.

        *   백준 11098 첼시를 도와줘

            int와 str을 입력 할 때 나누긴 힘들어서 lambda식을 사용해서 sorting할 때 int를 씌웠다.

        *   백준 1568 새

            함수를 만들어서 생성해줬는데 while문에서 내부 값을 돌리다가 남은 갯수보다 뺄값이 더 커질때 날라가는 숫자를 1로 바꾸는 방법도 있다.
    
    
