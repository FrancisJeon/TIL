<!-- 20210829 일 -->
<!--  




-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 자료구조와 알고리즘

    *   2018 카카오 블라인드

        *   [1차] 7번. 추석 트래픽 (난이도:상, 정답률 17.99%)

            **내 알고리즘**

            우선 1초 단위가 꼭 0.000에서 시작할 필요는 없고 특정 시점에서 1초간 최대 처리량을 찾아야 한다.

            1.  만약 모든 시작점/끝점의 1초에 해당하는 갯수를 구한다면 어떨까? 

                로그 문자열은 2000개라서 4천개의 비교 포인트가 생긴다. N^2의 경우에도 비효율적으로 보이진 않는다.

                각 점의 앞, 뒤로 1초를 해보는게 의미가 있어서 비교 갯수는 주어진 N의 4배

                *   시작점 ~ 끝점을 sorting 해볼까 했는데 이미 시간 순으로는 정렬에 범위로 주어져서 이분탐색의 의미는 없을듯

            2.  입력된 값중 "2016-09-15" 부분은 의미가 없다. ms 단위로 

                1000차이를 계산하는 알고리즘을 만들어야 하는데... 전부 60을 곱해서 숫자를 만들어줄까?

                시:분:초.밀리초에서 걸린시간 x.xxxs의 x.xxx부분을 이용해서 시작점과 끝점을 표현해야한다.
                $$
                60*60*1000*h + 60*1000*m + 1000 * s + ms
                $$

            3.  split으로 " "를 나눠준 다음 요일은 삭제 (전부 같은 요일)

                [1] 을 위의 계산식으로 계산해주고 [2]를 뺀 값이랑 두개를 하나의 리스트로 담아준다. (작은숫자가 앞으로가게)

                [시작점, 끝점] [시작점, 끝점] .....의 리스트가 만들어지고

                각 포인트를 돌면서 [시작점, 끝점] 에서 각각 앞,뒤 1초에 해당하는 갯수를 담아주자.

                최고로 높은 숫자를 찾으면 된다.

            **사용한 코드 분석**

            ```
            date, s, t = logs.split() # split()만 해주면 자동으로 공백을 받아서 나눠준다.
            t.replace('s', '') # replace로 s를 삭제해주는게 슬라이싱 후 float처리보다 더 깔끔
            (int(s[0])*3600 + int(s[1])*60 + float(s[2])) * 1000 이 방식이 내 방식보다 조금 더 깔끔
            
            def throughput(log, start, end): 
            # 쓰루풋 함수를 이용해서 answer을 계속 덮어씌운다.
            # 여기는 공부를 더 해봐야겠다. 이해가 안되는 부분이 잡혀서
            	cnt = 0
            	for x in log:
            		if x[0] < end and x[1] >= start:
            			cnt += 1
            	return cnt
            
            쓰루풋 함수를 이용한 answer의 max 함수
            answer = max(answer, throughput(log, x[0], x[0] + 1000), throughput(log, x[1], x[1] + 1000))
            
            ```

            