<!-- 20211006 수 -->
<!--  



-->

## 1. 오늘 한 일 📅

*   알고리즘

## 2. 오늘의 공부 정리 🗒️

*   ### 알고리즘

    *   팁

        *   큐의 개념과 응용 (미로찾기) https://www.youtube.com/watch?v=16SLOYDCYuc

            BFS로 미로찾기를 할 때 추가 배열을 쓰지 않기 위해 방문표시를 음수로 저장한다.

        *   프림 알고리즘 (https://victorydntmd.tistory.com/102)

            BFS처럼 시작점을 기준으로 간선이 확장해 나가는 방식, 최소한의 비용을 갖는 트리를 만들어야 한다.

            **최소 우선순위 큐**에서 가중치 가장 작은 정점 선택 후, 인접한 정점들에 대해 key값과 가중치 비교하여 갱신할지 말지 결정한다.

            1.  start vertex 설정 할 때 초기값으로 0을 할당한다. 
                [INF] * (N+1), [start] = 0
        2.  선택된 vertex의 인접 간선 가중치와 정점의 key를 확인한다. 가중치가 더 작을 때 가중치의 값으로 바꾼다.
                우선순위 queue = {5, 7, inf, 6, inf, 9} # 0이던 첫 vertex는 pop 했다.
            3.  이 때 queue에서 5에 들러서 7을 보면 10인 간선이 존재하지만 기존의 값이 더 크니까 변경하지 않는다.

        *   크루스칼과 프림의 차이 (https://hillier.tistory.com/54)

            크루스칼은 간선을 정렬해야 하므로 간선이 적을 땐 크루스칼, 많으면 프림을 선택한다.

    *   문제풀이

        *   **백준 1197 최소 스패닝 트리 - 프림, 크루스칼**

            위의 프림 알고리즘을 사용했으나 메모리 초과가 떴다. (알고리즘을 잘 몰라서 내가 작성한 형태가 다익스트라인것 같다.)

            크루스칼을 이용해서 완성하긴 했으나 나중에 다시 살펴봐야할듯 하다.

        *   백준 3085 사탕 게임 - 브루트포스

            길이가 n인 결과가 나오면 exit() - 최댓값이다.

            swap 여부는 우측 또는 하단의 색을 보고 결정하고 좌우 또는 상하 교환에 관련된 3개의 행+열에서만 max 길이를 구해서 계속 최신화 시키기
